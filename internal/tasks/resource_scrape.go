/******************************************************************************
*
*  Copyright 2019 SAP SE
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
*
******************************************************************************/

package tasks

import (
	"database/sql"
	"fmt"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/sapcc/go-bits/logg"
	"github.com/sapcc/go-bits/sqlext"
	"gopkg.in/gorp.v2"

	"github.com/sapcc/castellum/internal/db"
)

// query that finds the next resource that needs to be scraped
//
// WARNING: This must be run in a transaction, or else `FOR UPDATE SKIP LOCKED`
// will not work as expected.
var scrapeResourceSearchQuery = sqlext.SimplifyWhitespace(`
	SELECT * FROM resources
	WHERE (scraped_at IS NULL or scraped_at < $1)
	-- order by update priority (first new resources, then outdated resources, then ID for deterministic test behavior)
	ORDER BY COALESCE(scraped_at, to_timestamp(-1)) ASC, id ASC
	-- prevent other job loops from working on the same asset concurrently
	FOR UPDATE SKIP LOCKED LIMIT 1
`)

// PollForResourceScrapes returns a JobPoller that finds the next resource of the
// given asset type that needs scraping. The returned Job scrapes it, i.e. it
// looks for new and deleted assets within that resource.
func (c *Context) PollForResourceScrapes(minAge time.Duration) JobPoller {
	return func() (j Job, returnedError error) {
		defer func() {
			if returnedError != nil && returnedError != sql.ErrNoRows {
				labels := prometheus.Labels{"asset": "early-db-access"}
				resourceScrapeFailedCounter.With(labels).Inc()
			}
		}()

		//we need a DB transaction for the row-level locking to work correctly
		tx, err := c.DB.Begin()
		if err != nil {
			return nil, err
		}
		defer func() {
			if returnedError != nil {
				sqlext.RollbackUnlessCommitted(tx)
			}
		}()

		//find resource to scrape
		var res db.Resource
		maxScrapedAt := c.TimeNow().Add(-minAge)
		logg.Debug("looking for resource to scrape, maxScrapedAt = %s", maxScrapedAt.String())
		err = tx.SelectOne(&res, scrapeResourceSearchQuery, maxScrapedAt)
		if err != nil {
			if err == sql.ErrNoRows {
				logg.Debug("no resources to scrape - slowing down...")
				//nolint:errcheck
				tx.Rollback() //avoid the log line generated by sqlext.RollbackUnlessCommitted()
				return nil, sql.ErrNoRows
			}
			return nil, err
		}

		return resourceScrapeJob{c, tx, res}, nil
	}
}

type resourceScrapeJob struct {
	c   *Context
	tx  *gorp.Transaction
	res db.Resource
}

// Execute implements the Job interface.
func (j resourceScrapeJob) Execute() (returnedError error) {
	c := j.c
	tx := j.tx
	res := j.res

	defer sqlext.RollbackUnlessCommitted(tx)

	defer func() {
		labels := prometheus.Labels{"asset": string(res.AssetType)}
		if returnedError == nil {
			resourceScrapeSuccessCounter.With(labels).Inc()
		} else if returnedError != sql.ErrNoRows {
			resourceScrapeFailedCounter.With(labels).Inc()
		}
	}()

	manager, info := c.Team.ForAssetType(res.AssetType)
	if manager == nil {
		return fmt.Errorf("no asset manager for asset type %q", res.AssetType)
	}
	logg.Debug("scraping %s resource in scope %s using manager %v", res.AssetType, res.ScopeUUID, manager)

	//check which assets exist in this resource in OpenStack
	assetUUIDs, err := manager.ListAssets(res)
	if err != nil {
		//In case of error we update checked_at so that the next call continues
		//but leave scraped_at unchanged to indicate old data
		res.CheckedAt = c.TimeNow()
		res.ScrapeErrorMessage = err.Error()
		_, dbErr := tx.Update(&res)
		if dbErr != nil {
			return dbErr
		}
		dbErr = tx.Commit()
		if dbErr != nil {
			return dbErr
		}
		return fmt.Errorf("cannot list %s assets in scope %s: %s", string(res.AssetType), res.ScopeUUID, err.Error())
	}
	logg.Debug("scraped %d assets for %s resource for scope %s", len(assetUUIDs), res.AssetType, res.ScopeUUID)
	isExistingAsset := make(map[string]bool, len(assetUUIDs))
	for _, uuid := range assetUUIDs {
		isExistingAsset[uuid] = true
	}

	//load existing asset entries from DB
	var dbAssets []db.Asset
	_, err = tx.Select(&dbAssets, `SELECT * FROM assets WHERE resource_id = $1`, res.ID)
	if err != nil {
		return err
	}

	now := c.TimeNow()
	res.CheckedAt = now
	res.ScrapedAt = &now
	res.ScrapeErrorMessage = ""

	//cleanup asset entries for deleted assets
	isAssetInDB := make(map[string]bool)
	for _, dbAsset := range dbAssets {
		isAssetInDB[dbAsset.UUID] = true
		if isExistingAsset[dbAsset.UUID] {
			continue
		}
		logg.Info("removing deleted %s asset from DB: UUID = %s, scope UUID = %s", res.AssetType, dbAsset.UUID, res.ScopeUUID)
		_, err = tx.Delete(&dbAsset)
		if err != nil {
			return err
		}
	}

	//create entries for new assets
	for _, assetUUID := range assetUUIDs {
		if isAssetInDB[assetUUID] {
			continue
		}
		logg.Info("adding new %s asset to DB: UUID = %s, scope UUID = %s", res.AssetType, assetUUID, res.ScopeUUID)
		now := c.TimeNow()
		dbAsset := db.Asset{
			ResourceID:   res.ID,
			UUID:         assetUUID,
			CheckedAt:    now,
			ExpectedSize: nil,
		}

		status, err := manager.GetAssetStatus(res, assetUUID, nil)
		labels := prometheus.Labels{"asset": string(res.AssetType)}
		if err == nil {
			assetScrapeSuccessCounter.With(labels).Inc()
			dbAsset.Size = status.Size
			dbAsset.Usage = status.Usage
			dbAsset.ScrapedAt = &now
		} else {
			assetScrapeFailedCounter.With(labels).Inc()
			dbAsset.Size = 0
			dbAsset.Usage = info.MakeZeroUsageValues()
			dbAsset.ScrapeErrorMessage = err.Error()
		}

		err = tx.Insert(&dbAsset)
		if err != nil {
			return err
		}
	}

	//record successful scrape
	_, err = tx.Update(&res)
	if err != nil {
		return err
	}

	return tx.Commit()
}
