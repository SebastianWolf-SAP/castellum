/******************************************************************************
*
*  Copyright 2019 SAP SE
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
*
******************************************************************************/

package tasks

import (
	"database/sql"
	"fmt"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/sapcc/go-bits/logg"
	"gopkg.in/gorp.v2"

	"github.com/sapcc/castellum/internal/core"
	"github.com/sapcc/castellum/internal/db"
)

//WARNING: This must be run in a transaction, or else `FOR UPDATE SKIP LOCKED`
//will not work as expected.
var selectAndDeleteNextResizeQuery = db.SimplifyWhitespaceInSQL(`
	DELETE FROM pending_operations WHERE id = (
		SELECT id FROM pending_operations WHERE greenlit_at < $1 AND (retry_at IS NULL OR retry_at < $1)
		ORDER BY reason ASC LIMIT 1
		FOR UPDATE SKIP LOCKED
	) RETURNING *
`)

const (
	maxRetries    = 3
	retryInterval = 2 * time.Minute
)

//PollForAssetResizes is a JobPoller that finds the next pending operation. The
//returned Job executes the pending operation, i.e. moves it from status
//"greenlit" to either "succeeded", "failed" or "errored".
func (c *Context) PollForAssetResizes() (j Job, returnedError error) {
	defer func() {
		if returnedError != nil && returnedError != sql.ErrNoRows {
			labels := prometheus.Labels{"asset": "early-db-access"}
			assetResizeErroredCounter.With(labels).Inc()
		}
	}()

	//we need a DB transaction for the row-level locking to work correctly
	tx, err := c.DB.Begin()
	if err != nil {
		return nil, err
	}
	defer func() {
		if returnedError != nil {
			core.RollbackUnlessCommitted(tx)
		}
	}()

	//select the next greenlit PendingOperation (and delete it immediately)
	var op db.PendingOperation
	err = tx.SelectOne(&op, selectAndDeleteNextResizeQuery, c.TimeNow())
	if err != nil {
		if err == sql.ErrNoRows {
			logg.Debug("no assets to resize - slowing down...")
			tx.Rollback() //avoid the log line generated by core.RollbackUnlessCommitted()
			return nil, sql.ErrNoRows
		}
		return nil, err
	}

	return assetResizeJob{c, tx, op}, nil
}

type assetResizeJob struct {
	c  *Context
	tx *gorp.Transaction
	op db.PendingOperation
}

//Execute implements the Job interface.
func (j assetResizeJob) Execute() (returnedError error) {
	c := j.c
	tx := j.tx
	op := j.op

	defer core.RollbackUnlessCommitted(tx)

	var asset db.Asset
	var res db.Resource

	defer func() {
		labels := prometheus.Labels{"asset": string(res.AssetType)}
		if res.AssetType == "" { //because we did not get to loading it
			labels["asset"] = "early-db-access"
		}
		if returnedError == nil {
			assetResizeCounter.With(labels).Inc()
		} else {
			assetResizeErroredCounter.With(labels).Inc()
		}
	}()

	//find the corresponding asset, resource and asset manager
	err := tx.SelectOne(&asset, `SELECT * FROM assets WHERE id = $1`, op.AssetID)
	if err != nil {
		return err
	}
	err = tx.SelectOne(&res, `SELECT * FROM resources WHERE id = $1`, asset.ResourceID)
	if err != nil {
		return err
	}
	manager, _ := c.Team.ForAssetType(res.AssetType)
	if manager == nil {
		return fmt.Errorf("no asset manager for asset type %q", res.AssetType)
	}

	//when running in a unit test, wait for the test harness to unblock us
	if c.Blocker != nil {
		for range c.Blocker {
		}
	}

	//perform the resize operation (we give asset.Size instead of op.OldSize
	//since this is the most up-to-date asset size that we have)
	outcome, err := manager.SetAssetSize(res, asset.UUID, asset.Size, op.NewSize)
	errorMessage := ""
	if err != nil {
		logg.Error("cannot resize %s %s to size %d: %s", string(res.AssetType), asset.UUID, op.NewSize, err.Error())
		errorMessage = err.Error()
	}

	//if we have not exceeded our retry budget, put this operation back in the queue
	//
	//We only do this for outcome "errored", which indicates a system error.
	//These problems are usually discovered via alerts and quickly resolved, so
	//there is actual hope that everything will be better in a few minutes
	//without us failing the entire operation. For outcome "failed", we have a
	//user error and the user will likely only notice once they see the failed
	//operation in Castellum, so there is little use retrying here.
	if outcome == db.OperationOutcomeErrored && op.ErroredAttempts < maxRetries {
		op.ID = 0
		op.ErroredAttempts++
		retryAt := c.TimeNow().Add(retryInterval)
		op.RetryAt = &retryAt

		err = tx.Insert(&op)
		if err != nil {
			return err
		}
		return tx.Commit()
	}

	finishedOp := op.IntoFinishedOperation(outcome, c.TimeNow())
	finishedOp.ErrorMessage = errorMessage
	err = tx.Insert(&finishedOp)
	if err != nil {
		return err
	}

	//mark asset as having just completed as resize operation (see
	//logic in ScrapeNextAsset() for details)
	if outcome == db.OperationOutcomeSucceeded {
		_, err := tx.Exec(`UPDATE assets SET expected_size = $1 WHERE id = $2`,
			finishedOp.NewSize, asset.ID)
		if err != nil {
			return err
		}
	}

	core.CountStateTransition(res, asset.UUID, db.OperationStateGreenlit, finishedOp.State())
	return tx.Commit()
}
